<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Hallway Horror</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #fff;
    }

    #ui-top {
      position: fixed;
      top: 10px;
      left: 10px;
      z-index: 20;
      font-size: 13px;
      background: rgba(0, 0, 0, 0.75);
      padding: 6px 10px;
      border-radius: 6px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(4px);
    }

    #ui-top strong {
      display: block;
      font-size: 14px;
      margin-bottom: 3px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }

    #ui-top .objectives {
      margin-top: 4px;
      font-size: 12px;
      opacity: 0.9;
    }

    #help {
      position: fixed;
      bottom: 10px;
      left: 10px;
      z-index: 20;
      font-size: 11px;
      background: rgba(0, 0, 0, 0.75);
      padding: 6px 10px;
      border-radius: 6px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      opacity: 0.85;
    }

    #hint {
      position: fixed;
      bottom: 10px;
      right: 10px;
      z-index: 20;
      font-size: 11px;
      background: rgba(0, 0, 0, 0.75);
      padding: 6px 10px;
      border-radius: 6px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      opacity: 0.8;
      max-width: 220px;
      text-align: right;
    }

    #overlay {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      background: rgba(0, 0, 0, 0.95);
      z-index: 40;
      text-align: center;
    }

    #overlay h1 {
      font-size: 40px;
      letter-spacing: 0.2em;
      margin-bottom: 10px;
      text-transform: uppercase;
    }

    #overlay p {
      font-size: 13px;
      margin-bottom: 18px;
      color: #ddd;
      max-width: 320px;
      line-height: 1.5;
    }

    #overlay button {
      padding: 8px 18px;
      border-radius: 20px;
      border: 1px solid #fff;
      background: transparent;
      color: #fff;
      cursor: pointer;
      font-size: 13px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }

    #overlay button:hover {
      background: #fff;
      color: #000;
    }

    /* Red vignette that pulses when danger is close */
    #vignette {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 30;
      background:
        radial-gradient(circle at center,
          rgba(0, 0, 0, 0) 40%,
          rgba(0, 0, 0, 0.6) 70%,
          rgba(0, 0, 0, 0.95) 100%);
      mix-blend-mode: multiply;
      opacity: 1;
      transition: opacity 0.2s ease-out;
    }

    #danger {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 31;
      background:
        radial-gradient(circle at center,
          rgba(255, 0, 0, 0.15) 0%,
          rgba(0, 0, 0, 0.95) 70%);
      opacity: 0;
      transition: opacity 0.12s ease-out;
    }

    /* Subtle breathing at the bottom of the screen */
    #breath {
      position: fixed;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 60%;
      height: 15%;
      background: radial-gradient(ellipse at center,
        rgba(255, 255, 255, 0.07) 0%,
        rgba(255, 255, 255, 0) 60%);
      pointer-events: none;
      z-index: 15;
      opacity: 0.0;
      transition: opacity 0.3s ease-out;
    }

    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <div id="ui-top">
    <strong>Hallway Horror</strong>
    <div class="objectives">
      Toys collected:
      <span id="objCount">0</span> /
      <span id="objTotal">3</span><br />
      Escape through the front door after you have all toys.
    </div>
  </div>

  <div id="help">
    Move: W A S D or Arrow keys<br />
    Flashlight: F &nbsp;&nbsp; Sprint: Shift<br />
    Do not let the tall thing see you in the hallway.
  </div>

  <div id="hint">
    You are small. The house is not.<br />
    The tall thing hates the light.
  </div>

  <div id="overlay">
    <h1 id="overlayTitle"></h1>
    <p id="overlayText"></p>
    <button id="overlayBtn">Wake up</button>
  </div>

  <div id="vignette"></div>
  <div id="danger"></div>
  <div id="breath"></div>

  <!-- Low res sounds. Replace URLs if needed -->
  <audio id="ambience" src="https://upload.wikimedia.org/wikipedia/commons/1/10/White-noise.ogg" loop></audio>
  <audio id="heart" src="https://upload.wikimedia.org/wikipedia/commons/1/1e/Heartbeat_2.ogg" loop></audio>
  <audio id="monsterGrowl" src="https://upload.wikimedia.org/wikipedia/commons/3/3a/Lion_growl.ogg"></audio>

  <!-- Three.js -->
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>

  <script>
    // ================== BASIC SETUP ==========================

    let scene, camera, renderer;
    let player, monster, flashlight;
    let walls = [];
    let doors = [];
    let toys = [];
    let exitDoor;

    const HOUSE_SIZE = 36;
    const KID_HEIGHT = 1.3; // low camera height so you feel like a kid

    const keysState = {
      KeyW: false,
      KeyA: false,
      KeyS: false,
      KeyD: false,
      ArrowUp: false,
      ArrowDown: false,
      ArrowLeft: false,
      ArrowRight: false,
      ShiftLeft: false,
      ShiftRight: false,
      KeyF: false
    };

    let collected = 0;
    const totalToys = 3;
    let gameState = "playing"; // playing, win, lose, jumpscare
    let lastTime = 0;

    // Monster behaviour
    let monsterTarget = null;
    let monsterSeenPlayer = false;
    let monsterLastGrowl = 0;

    // UI elements
    const objCountEl = document.getElementById("objCount");
    const objTotalEl = document.getElementById("objTotal");
    const vignetteEl = document.getElementById("vignette");
    const dangerEl = document.getElementById("danger");
    const breathEl = document.getElementById("breath");
    const overlay = document.getElementById("overlay");
    const overlayTitle = document.getElementById("overlayTitle");
    const overlayText = document.getElementById("overlayText");
    const overlayBtn = document.getElementById("overlayBtn");

    objTotalEl.textContent = totalToys.toString();

    // Audio
    const ambience = document.getElementById("ambience");
    const heart = document.getElementById("heart");
    const monsterGrowl = document.getElementById("monsterGrowl");

    function safePlay(audio) {
      // Some browsers need a user interaction first
      audio.volume = 0;
      audio.play().then(() => {
        audio.pause();
        audio.currentTime = 0;
      }).catch(() => {});
    }

    // ================== INITIALISE ==========================

    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);
      scene.fog = new THREE.Fog(0x000000, 4, 50);

      camera = new THREE.PerspectiveCamera(
        70,
        window.innerWidth / window.innerHeight,
        0.1,
        200
      );

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Ambient house lighting
      const ambient = new THREE.AmbientLight(0xffffff, 0.03);
      scene.add(ambient);

      const moonLight = new THREE.DirectionalLight(0x666688, 0.25);
      moonLight.position.set(20, 25, -15);
      scene.add(moonLight);

      flashlight = new THREE.SpotLight(0xffffff, 2.5, 20, Math.PI / 7, 0.5, 1.5);
      flashlight.castShadow = true;
      flashlight.position.set(0, 5, 5);
      flashlight.target.position.set(0, 0, 0);
      scene.add(flashlight);
      scene.add(flashlight.target);
      flashlight.visible = true;

      // Floor
      const floorGeo = new THREE.PlaneGeometry(HOUSE_SIZE, HOUSE_SIZE);
      const floorMat = new THREE.MeshStandardMaterial({
        color: 0x101010,
        roughness: 0.95
      });
      const floor = new THREE.Mesh(floorGeo, floorMat);
      floor.rotation.x = -Math.PI / 2;
      floor.receiveShadow = true;
      scene.add(floor);

      createHouseLayout();
      createCeilingLights();
      createPlayer();
      createMonster();
      createToys();
      createExitDoor();

      // Camera start
      updateCameraInstant();

      // Listeners
      window.addEventListener("keydown", onKeyDown);
      window.addEventListener("keyup", onKeyUp);
      window.addEventListener("resize", onResize);
      overlayBtn.addEventListener("click", restartGame);

      // Prepare audio
      safePlay(ambience);
      safePlay(heart);
      safePlay(monsterGrowl);

      lastTime = performance.now();
      animate();
    }

    // ================== HOUSE LAYOUT ========================

    function createWall(width, depth, x, z, height = 3, color = 0x222222) {
      const wallMat = new THREE.MeshStandardMaterial({
        color,
        roughness: 0.9,
        metalness: 0.05
      });
      const geo = new THREE.BoxGeometry(width, height, depth);
      const mesh = new THREE.Mesh(geo, wallMat);
      mesh.position.set(x, height / 2, z);
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      scene.add(mesh);
      walls.push(mesh);
      return mesh;
    }

    function createDoorFrame(x, z, rotationY = 0) {
      // Just a visual frame in the hallway
      const frameMat = new THREE.MeshStandardMaterial({
        color: 0x151515,
        roughness: 0.7
      });
      const topGeo = new THREE.BoxGeometry(2.2, 0.3, 0.4);
      const sideGeo = new THREE.BoxGeometry(0.25, 2.4, 0.4);

      const group = new THREE.Group();

      const top = new THREE.Mesh(topGeo, frameMat);
      const left = new THREE.Mesh(sideGeo, frameMat);
      const right = new THREE.Mesh(sideGeo, frameMat);

      top.position.set(0, 2.1, 0);
      left.position.set(-0.95, 1.0, 0);
      right.position.set(0.95, 1.0, 0);

      group.add(top, left, right);
      group.position.set(x, 0, z);
      group.rotation.y = rotationY;
      scene.add(group);
      doors.push(group);
    }

    function createHouseLayout() {
      const thickness = 0.8;
      const h = HOUSE_SIZE;

      // Outer walls
      createWall(h, thickness, 0, -h / 2);
      createWall(h, thickness, 0, h / 2);
      createWall(thickness, h, -h / 2, 0);
      createWall(thickness, h, h / 2, 0);

      // Long main hallway from front door to back
      // Horizontal through the middle
      createWall(h - 6, thickness, 0, 0);

      // Vertical hall segment through the middle
      createWall(thickness, 18, 0, -4);

      // Create rooms around hallways
      // Top left room
      createWall(10, thickness, -10, -10);
      createWall(thickness, 10, -15, -6);
      createWall(thickness, 10, -5, -6);

      // Top right room
      createWall(10, thickness, 10, -10);
      createWall(thickness, 10, 5, -6);
      createWall(thickness, 10, 15, -6);

      // Bottom left room
      createWall(12, thickness, -11, 10);
      createWall(thickness, 8, -17, 6);
      createWall(thickness, 8, -5, 6);

      // Bottom right room
      createWall(10, thickness, 10, 10);
      createWall(thickness, 8, 5, 6);
      createWall(thickness, 8, 15, 6);

      // Doorway frames along hall
      createDoorFrame(-6, 0);
      createDoorFrame(6, 0);
      createDoorFrame(0, -6, Math.PI / 2);
      createDoorFrame(0, -12, Math.PI / 2);
    }

    // Flickering ceiling lights in the hallway
    const ceilingLights = [];

    function createCeilingLights() {
      const lightPositions = [
        new THREE.Vector3(-8, 2.8, 0),
        new THREE.Vector3(0, 2.8, 0),
        new THREE.Vector3(8, 2.8, 0),
        new THREE.Vector3(0, 2.8, -6),
        new THREE.Vector3(0, 2.8, -12)
      ];

      lightPositions.forEach((pos) => {
        const bulbMat = new THREE.MeshStandardMaterial({
          color: 0x777777,
          emissive: 0xffffff,
          emissiveIntensity: 0.2,
          roughness: 0.5
        });
        const bulbGeo = new THREE.BoxGeometry(0.3, 0.1, 0.7);
        const bulb = new THREE.Mesh(bulbGeo, bulbMat);
        bulb.position.copy(pos);
        scene.add(bulb);

        const light = new THREE.PointLight(0xffffff, 0.5, 8);
        light.position.set(pos.x, pos.y - 0.1, pos.z);
        scene.add(light);

        ceilingLights.push({ mesh: bulb, light, flickerOffset: Math.random() * 1000 });
      });
    }

    // ================== PLAYER ========================

    function createPlayer() {
      // Simple kid body, camera will be above chest
      const bodyGeo = new THREE.BoxGeometry(0.4, 1.0, 0.4);
      const bodyMat = new THREE.MeshStandardMaterial({
        color: 0xddddff,
        roughness: 0.7
      });
      player = new THREE.Mesh(bodyGeo, bodyMat);
      player.position.set(0, 0.5, HOUSE_SIZE / 2 - 3);
      scene.add(player);
    }

    function updatePlayer(delta) {
      const baseSpeed = 3.0;
      const sprintBonus = 1.5;
      const isSprinting = keysState.ShiftLeft || keysState.ShiftRight;
      const speed = baseSpeed * (isSprinting ? sprintBonus : 1);

      let dx = 0;
      let dz = 0;

      if (keysState.KeyW || keysState.ArrowUp) dz -= speed * delta;
      if (keysState.KeyS || keysState.ArrowDown) dz += speed * delta;
      if (keysState.KeyA || keysState.ArrowLeft) dx -= speed * delta;
      if (keysState.KeyD || keysState.ArrowRight) dx += speed * delta;

      if (dx !== 0 && dz !== 0) {
        const inv = 1 / Math.sqrt(2);
        dx *= inv;
        dz *= inv;
      }

      attemptMove(player, dx, dz, 0.35);

      // Head bob / breathing
      if (dx !== 0 || dz !== 0) {
        breathEl.style.opacity = isSprinting ? "0.55" : "0.3";
      } else {
        breathEl.style.opacity = "0.08";
      }

      // Face camera direction roughly
      if (dx !== 0 || dz !== 0) {
        player.rotation.y = Math.atan2(dx, dz);
      }

      // Toy collection
      toys.forEach((toy) => {
        if (!toy.visible) return;
        toy.rotation.y += delta * 2.5;
        toy.position.y = 0.25 + Math.sin(performance.now() * 0.003 + toy.userData.phase) * 0.08;

        const dist = toy.position.distanceTo(player.position);
        if (dist < 0.6) {
          toy.visible = false;
          collected += 1;
          objCountEl.textContent = collected.toString();
        }
      });

      // Exit door interaction
      if (collected >= totalToys) {
        const distToExit = exitDoor.position.distanceTo(player.position);
        if (distToExit < 2.0 && gameState === "playing") {
          triggerWin();
        }
      }
    }

    function updateCameraAndLight(delta) {
      const camOffset = new THREE.Vector3(0, KID_HEIGHT, -0.2);
      const behindOffset = new THREE.Vector3(0, 0, 0.8);

      // Camera follows player from slightly behind and above
      const targetPos = new THREE.Vector3(
        player.position.x + behindOffset.x,
        player.position.y + camOffset.y,
        player.position.z + behindOffset.z
      );
      camera.position.lerp(targetPos, 0.2);
      camera.lookAt(player.position.x, player.position.y + 0.4, player.position.z);

      // Flashlight follows camera with slight jitter
      const t = performance.now() * 0.002;
      const jitter = flashlight.visible ? 0.05 : 0;
      flashlight.position.copy(camera.position);
      flashlight.position.x += Math.sin(t * 1.7) * jitter;
      flashlight.position.y += Math.sin(t * 2.3) * jitter;

      const flashlightTarget = player.position.clone();
      flashlightTarget.y += 0.3;
      flashlight.target.position.lerp(flashlightTarget, 0.3);
      flashlight.target.updateMatrixWorld();
    }

    function updateCameraInstant() {
      camera.position.set(player.position.x, player.position.y + KID_HEIGHT, player.position.z + 0.8);
      camera.lookAt(player.position.x, player.position.y + 0.4, player.position.z);
    }

    // ================== MONSTER ========================

    function createMonster() {
      const monsterGeo = new THREE.BoxGeometry(0.8, 3.5, 0.5);
      const monsterMat = new THREE.MeshStandardMaterial({
        color: 0x050505,
        emissive: 0x440000,
        emissiveIntensity: 1.0,
        roughness: 0.6
      });
      monster = new THREE.Mesh(monsterGeo, monsterMat);
      monster.position.set(-HOUSE_SIZE / 2 + 5, 1.75, 0);
      scene.add(monster);

      // Long thin arms
      const armGeo = new THREE.BoxGeometry(0.18, 2.3, 0.18);
      const armMat = new THREE.MeshStandardMaterial({
        color: 0x080808,
        emissive: 0x330000,
        emissiveIntensity: 0.8
      });
      const leftArm = new THREE.Mesh(armGeo, armMat);
      const rightArm = new THREE.Mesh(armGeo, armMat);
      leftArm.position.set(-0.7, -0.3, 0);
      rightArm.position.set(0.7, -0.3, 0);
      monster.add(leftArm);
      monster.add(rightArm);

      // Eyes and mouth
      const eyeGeo = new THREE.BoxGeometry(0.15, 0.15, 0.05);
      const eyeMat = new THREE.MeshStandardMaterial({
        color: 0xff0000,
        emissive: 0xff0000,
        emissiveIntensity: 1.8
      });
      const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
      const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
      leftEye.position.set(-0.2, 0.8, 0.28);
      rightEye.position.set(0.2, 0.8, 0.28);
      monster.add(leftEye, rightEye);

      const mouthGeo = new THREE.BoxGeometry(0.5, 0.08, 0.05);
      const mouthMat = new THREE.MeshStandardMaterial({
        color: 0xaa0000,
        emissive: 0xaa0000,
        emissiveIntensity: 1.5
      });
      const mouth = new THREE.Mesh(mouthGeo, mouthMat);
      mouth.position.set(0, 0.4, 0.28);
      monster.add(mouth);

      const monsterLight = new THREE.PointLight(0xff0000, 1.2, 10);
      monster.add(monsterLight);
    }

    function chooseNewMonsterTarget() {
      const spots = [
        new THREE.Vector3(-10, monster.position.y, 0),
        new THREE.Vector3(10, monster.position.y, 0),
        new THREE.Vector3(0, monster.position.y, -6),
        new THREE.Vector3(0, monster.position.y, -12),
        new THREE.Vector3(-8, monster.position.y, -6),
        new THREE.Vector3(8, monster.position.y, -6)
      ];
      monsterTarget = spots[Math.floor(Math.random() * spots.length)].clone();
    }

    function updateMonster(delta) {
      const distToPlayer = monster.position.distanceTo(player.position);
      const inHallWithPlayer = Math.abs(monster.position.z) < 2 && Math.abs(player.position.z) < 2;

      const alertDistance = 7;
      const chaseDistance = 11;

      let speed = 1.3;
      let targetPos;

      // If monster is near and sees player in hall, full chase
      if (distToPlayer < chaseDistance && inHallWithPlayer) {
        targetPos = player.position;
        speed = 3.4;
        monsterSeenPlayer = true;

        const now = performance.now();
        if (now - monsterLastGrowl > 4000) {
          monsterGrowl.currentTime = 0;
          monsterGrowl.volume = 0.5;
          monsterGrowl.play().catch(() => {});
          monsterLastGrowl = now;
        }
      } else if (monsterSeenPlayer || distToPlayer < alertDistance) {
        // Slow chase if player was seen earlier
        targetPos = player.position;
        speed = 2.3;
      } else {
        // Patrol mode
        if (!monsterTarget || monster.position.distanceTo(monsterTarget) < 0.5) {
          chooseNewMonsterTarget();
        }
        targetPos = monsterTarget;
        speed = 1.1;
      }

      const dir = new THREE.Vector3().subVectors(targetPos, monster.position);
      dir.y = 0;
      const dist = dir.length();
      if (dist > 0.01) {
        dir.normalize();
        const stepX = dir.x * speed * delta;
        const stepZ = dir.z * speed * delta;
        attemptMove(monster, stepX, stepZ, 0.35);
      }

      // Creepy sway
      monster.position.y = 1.75 + Math.sin(performance.now() * 0.003) * 0.12;
      monster.rotation.y = Math.atan2(
        player.position.x - monster.position.x,
        player.position.z - monster.position.z
      );

      // Catch condition
      if (distToPlayer < 1.0 && gameState === "playing") {
        triggerJumpscare();
      }

      updateFearEffects(distToPlayer);
    }

    // ================== TOYS AND EXIT ========================

    function createToys() {
      const positions = [
        new THREE.Vector3(-12, 0.25, -8),
        new THREE.Vector3(12, 0.25, 8),
        new THREE.Vector3(-10, 0.25, 10)
      ];

      positions.forEach((pos, i) => {
        const geo = new THREE.SphereGeometry(0.3, 18, 18);
        const mat = new THREE.MeshStandardMaterial({
          color: 0x00ffd5,
          emissive: 0x00ffd5,
          emissiveIntensity: 1.3,
          roughness: 0.2
        });
        const toy = new THREE.Mesh(geo, mat);
        toy.position.copy(pos);
        toy.userData.phase = i * 1.2;
        scene.add(toy);
        toys.push(toy);
      });
    }

    function createExitDoor() {
      // Front door at far end of hallway
      exitDoor = new THREE.Group();
      exitDoor.position.set(0, 0, HOUSE_SIZE / 2 - 0.5);

      const frameMat = new THREE.MeshStandardMaterial({
        color: 0x181818,
        roughness: 0.7
      });
      const doorMat = new THREE.MeshStandardMaterial({
        color: 0x202020,
        roughness: 0.9
      });

      const frameTopGeo = new THREE.BoxGeometry(3, 0.3, 0.4);
      const frameSideGeo = new THREE.BoxGeometry(0.25, 2.8, 0.4);
      const doorGeo = new THREE.BoxGeometry(2.2, 2.6, 0.2);

      const frameTop = new THREE.Mesh(frameTopGeo, frameMat);
      const frameLeft = new THREE.Mesh(frameSideGeo, frameMat);
      const frameRight = new THREE.Mesh(frameSideGeo, frameMat);
      const door = new THREE.Mesh(doorGeo, doorMat);

      frameTop.position.set(0, 2.3, 0);
      frameLeft.position.set(-1.4, 1.1, 0);
      frameRight.position.set(1.4, 1.1, 0);
      door.position.set(0, 1.1, 0);

      exitDoor.add(frameTop, frameLeft, frameRight, door);
      scene.add(exitDoor);
    }

    // ================== COLLISION ========================

    function attemptMove(obj, dx, dz, radius = 0.4) {
      const newPos = obj.position.clone();
      newPos.x += dx;
      newPos.z += dz;

      for (const wall of walls) {
        const wx = wall.position.x;
        const wy = wall.position.y;
        const wz = wall.position.z;
        const params = wall.geometry.parameters;
        const sx = params.width / 2;
        const sy = params.height / 2;
        const sz = params.depth / 2;

        if (
          newPos.x + radius > wx - sx &&
          newPos.x - radius < wx + sx &&
          newPos.y + radius > wy - sy &&
          newPos.y - radius < wy + sy &&
          newPos.z + radius > wz - sz &&
          newPos.z - radius < wz + sz
        ) {
          return;
        }
      }

      obj.position.copy(newPos);
    }

    // ================== FEAR EFFECTS ========================

    function updateFearEffects(distToPlayer) {
      // Vignette is always on a bit
      vignetteEl.style.opacity = "1";

      // Heartbeat and danger overlay scale with distance
      const maxRange = 15;
      const clamped = Math.max(0, Math.min(maxRange, maxRange - distToPlayer));
      const danger = clamped / maxRange; // 0 to 1

      dangerEl.style.opacity = (danger * 0.9).toString();

      // Audio volumes
      ambience.volume = 0.22;
      heart.volume = Math.min(0.9, danger * 1.1);

      if (gameState === "playing") {
        if (heart.paused && danger > 0.1) {
          heart.currentTime = 0;
          heart.play().catch(() => {});
        }
        if (ambience.paused) {
          ambience.play().catch(() => {});
        }
      }

      // Small breathing boost when close
      if (danger > 0.5) {
        breathEl.style.opacity = "0.7";
      }
    }

    // ================== INPUT ========================

    function onKeyDown(e) {
      if (keysState.hasOwnProperty(e.code)) {
        keysState[e.code] = true;

        // Toggle flashlight on F press
        if (e.code === "KeyF") {
          flashlight.visible = !flashlight.visible;
        }
      }

      if (gameState !== "playing" && e.code === "Space") {
        restartGame();
      }

      // Try to start ambience when user presses something
      ambience.play().catch(() => {});
      heart.play().catch(() => heart.pause());
    }

    function onKeyUp(e) {
      if (keysState.hasOwnProperty(e.code)) {
        keysState[e.code] = false;
      }
    }

    function onResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // ================== GAME STATE ========================

    function triggerWin() {
      gameState = "win";
      overlayTitle.textContent = "You Got Out";
      overlayTitle.style.color = "#66ff99";
      overlayText.textContent = "You found your toys and slipped out through the front door. Maybe it was only a nightmare. Maybe it now knows your name.";
      overlayBtn.textContent = "Play again";
      overlay.style.display = "flex";

      heart.pause();
    }

    function triggerJumpscare() {
      gameState = "jumpscare";
      dangerEl.style.opacity = "1";

      // Camera snap to monster face
      const monsterFace = monster.position.clone();
      monsterFace.y += 0.6;
      camera.position.copy(monsterFace.clone().add(new THREE.Vector3(0, 0, 0.01)));
      camera.lookAt(monsterFace);

      monsterGrowl.currentTime = 0;
      monsterGrowl.volume = 0.8;
      monsterGrowl.play().catch(() => {});

      setTimeout(() => {
        triggerLose();
      }, 450);
    }

    function triggerLose() {
      gameState = "lose";
      overlayTitle.textContent = "It Found You";
      overlayTitle.style.color = "#ff4444";
      overlayText.textContent = "You froze in the hallway and felt something tall lean over you. The house is quiet again. It is waiting for you to come back.";
      overlayBtn.textContent = "Try again";
      overlay.style.display = "flex";

      heart.pause();
    }

    function restartGame() {
      overlay.style.display = "none";
      gameState = "playing";
      collected = 0;
      objCountEl.textContent = "0";
      monsterSeenPlayer = false;
      monsterTarget = null;

      player.position.set(0, 0.5, HOUSE_SIZE / 2 - 3);
      monster.position.set(-HOUSE_SIZE / 2 + 5, 1.75, 0);

      toys.forEach((toy) => {
        toy.visible = true;
      });

      dangerEl.style.opacity = "0";
      breathEl.style.opacity = "0.1";

      updateCameraInstant();

      ambience.play().catch(() => {});
    }

    // ================== LOOP ========================

    function animate() {
      requestAnimationFrame(animate);

      const now = performance.now();
      const delta = (now - lastTime) / 1000;
      lastTime = now;

      // Flicker house lights
      ceilingLights.forEach((item) => {
        const t = now * 0.003 + item.flickerOffset;
        const flicker = 0.7 + Math.sin(t) * 0.3 + (Math.random() * 0.08 - 0.04);
        const intensity = Math.max(0.1, Math.min(1.2, flicker));
        item.light.intensity = intensity;
        item.mesh.material.emissiveIntensity = intensity * 0.4;
      });

      if (gameState === "playing") {
        updatePlayer(delta);
        updateMonster(delta);
        updateCameraAndLight(delta);
      } else if (gameState === "jumpscare") {
        // Keep rendering but no input
      }

      renderer.render(scene, camera);
    }

    // Start
    init();
  </script>
</body>
</html>
