<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Skinwalker Park</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #fff;
    }

    canvas {
      display: block;
    }

    #hud {
      position: fixed;
      top: 10px;
      left: 10px;
      z-index: 10;
      padding: 8px 12px;
      background: rgba(0, 0, 0, 0.8);
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      font-size: 13px;
      backdrop-filter: blur(4px);
    }

    #hud strong {
      text-transform: uppercase;
      letter-spacing: 0.08em;
      font-size: 13px;
    }

    #hud .sub {
      font-size: 12px;
      opacity: 0.9;
      margin-top: 4px;
    }

    #hud .line {
      margin-top: 4px;
      font-size: 11px;
      opacity: 0.85;
    }

    #levelInfo {
      margin-top: 4px;
      font-size: 12px;
    }

    #staminaContainer {
      margin-top: 6px;
      width: 160px;
      height: 7px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.3);
      overflow: hidden;
    }

    #staminaBar {
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, #6cff6c, #ffeb3b, #ff5252);
      transform-origin: left center;
      transform: scaleX(1);
    }

    #controls {
      position: fixed;
      left: 10px;
      bottom: 10px;
      z-index: 10;
      padding: 6px 10px;
      background: rgba(0, 0, 0, 0.8);
      border-radius: 6px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      font-size: 11px;
      opacity: 0.85;
    }

    #hint {
      position: fixed;
      right: 10px;
      bottom: 10px;
      z-index: 10;
      padding: 6px 10px;
      background: rgba(0, 0, 0, 0.8);
      border-radius: 6px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      font-size: 11px;
      opacity: 0.85;
      max-width: 240px;
      text-align: right;
    }

    #vignette {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 5;
      background:
        radial-gradient(circle at center,
          rgba(0,0,0,0) 40%,
          rgba(0,0,0,0.6) 70%,
          rgba(0,0,0,0.95) 100%);
      opacity: 1;
    }

    #dangerOverlay {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 6;
      background:
        radial-gradient(circle at center,
          rgba(0,100,255,0.0) 0%,
          rgba(0,0,0,0.9) 70%);
      opacity: 0;
      transition: opacity 0.15s ease-out;
    }

    #overlay {
      position: fixed;
      inset: 0;
      z-index: 20;
      background: rgba(0, 0, 0, 0.96);
      display: none;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      text-align: center;
    }

    #overlay h1 {
      font-size: 40px;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      margin-bottom: 10px;
    }

    #overlay p {
      font-size: 14px;
      max-width: 320px;
      line-height: 1.5;
      color: #ddd;
      margin-bottom: 18px;
    }

    #overlay button {
      padding: 8px 18px;
      border-radius: 999px;
      border: 1px solid #fff;
      background: transparent;
      color: #fff;
      font-size: 13px;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      cursor: pointer;
    }

    #overlay button:hover {
      background: #fff;
      color: #000;
    }

    #startHint {
      position: fixed;
      inset: 0;
      z-index: 18;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      background: radial-gradient(circle at center, rgba(0,0,0,0.5) 0%, #000 70%);
      color: #aaa;
      font-size: 13px;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="hud">
    <strong>Skinwalker Park</strong>
    <div class="sub">
      Survive. Stay away from the tall ones.
    </div>
    <div id="levelInfo">Level: <span id="levelNum">1</span></div>
    <div class="line">When you hear whistling and footsteps, run.</div>
    <div id="staminaContainer">
      <div id="staminaBar"></div>
    </div>
  </div>

  <div id="controls">
    Move: W A S D / Arrows<br />
    Sprint: Shift &nbsp;&nbsp; Flashlight: F<br />
    Zoom: Mouse wheel
  </div>

  <div id="hint">
    You start in a clearing.<br />
    The trees hide things that do not like being watched.
  </div>

  <div id="vignette"></div>
  <div id="dangerOverlay"></div>

  <div id="overlay">
    <h1 id="overlayTitle"></h1>
    <p id="overlayText"></p>
    <button id="overlayBtn">Play again</button>
  </div>

  <div id="startHint">
    Click the game window and press any key to wake up in the park.
  </div>

  <!-- Simple placeholder sounds. You can replace with your own files -->
  <audio id="whistleSound" src="https://upload.wikimedia.org/wikipedia/commons/6/6b/Whistling.ogg"></audio>
  <audio id="stepsSound" src="https://upload.wikimedia.org/wikipedia/commons/6/67/Footsteps_on_gravel.ogg" loop></audio>

  <!-- Three.js -->
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>

  <script>
    // ============ BASIC SETUP ============

    let scene, camera, renderer;
    let player, playerGroup;
    let flashlight;
    let stars;
    let ground;
    let trees = [];
    let skinwalkers = [];

    const PARK_RADIUS = 70;
    const CLEARING_RADIUS = 10;
    const PLAYER_RADIUS = 0.6;

    const keys = {
      KeyW: false, KeyA: false, KeyS: false, KeyD: false,
      ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false,
      ShiftLeft: false, ShiftRight: false,
      KeyF: false
    };

    let lastTime = 0;
    let cameraDistance = 7;
    let cameraMin = 3;
    let cameraMax = 14;

    let stamina = 1;
    let staminaCooldown = 0;
    const staminaBar = document.getElementById("staminaBar");

    let gameState = "waiting"; // waiting, playing, dead
    const overlay = document.getElementById("overlay");
    const overlayTitle = document.getElementById("overlayTitle");
    const overlayText = document.getElementById("overlayText");
    const overlayBtn = document.getElementById("overlayBtn");
    const startHint = document.getElementById("startHint");

    const dangerOverlay = document.getElementById("dangerOverlay");
    const levelNumEl = document.getElementById("levelNum");

    // Level / wave system
    let level = 1;
    let levelTime = 0;
    const levelLength = 60; // seconds before next level
    const baseSkinwalkers = 3;

    // Sounds
    const whistleSound = document.getElementById("whistleSound");
    const stepsSound = document.getElementById("stepsSound");

    function tryPlay(audio, volume = 1) {
      audio.volume = volume;
      audio.play().catch(() => {});
    }

    // ============ INIT ============

    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);
      scene.fog = new THREE.Fog(0x000000, 15, 130);

      camera = new THREE.PerspectiveCamera(
        70,
        window.innerWidth / window.innerHeight,
        0.1,
        300
      );

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.body.appendChild(renderer.domElement);

      createLights();
      createGround();
      createStars();
      createTrees();
      createPlayer();
      createSkinwalkersForLevel(level);

      updateCameraInstant();

      window.addEventListener("keydown", onKeyDown);
      window.addEventListener("keyup", onKeyUp);
      window.addEventListener("resize", onResize);
      window.addEventListener("wheel", onWheel);
      overlayBtn.addEventListener("click", restartGame);

      lastTime = performance.now();
      animate();
    }

    // ============ LIGHTS, SKY, GROUND ============

    function createLights() {
      const ambient = new THREE.AmbientLight(0x7799ff, 0.2);
      scene.add(ambient);

      const moon = new THREE.DirectionalLight(0x99bbff, 0.7);
      moon.position.set(50, 80, -20);
      moon.castShadow = true;
      moon.shadow.mapSize.set(2048, 2048);
      moon.shadow.camera.near = 10;
      moon.shadow.camera.far = 200;
      moon.shadow.camera.left = -100;
      moon.shadow.camera.right = 100;
      moon.shadow.camera.top = 100;
      moon.shadow.camera.bottom = -100;
      scene.add(moon);

      flashlight = new THREE.SpotLight(0xffffff, 2.4, 35, Math.PI / 7, 0.4, 1.4);
      flashlight.castShadow = true;
      flashlight.position.set(0, 2, 0);
      flashlight.target.position.set(0, 0, -1);
      flashlight.visible = true;
      scene.add(flashlight);
      scene.add(flashlight.target);
    }

    function createGround() {
      const geo = new THREE.CircleGeometry(PARK_RADIUS, 64);
      const mat = new THREE.MeshStandardMaterial({
        color: 0x0b0f12,
        roughness: 0.95,
        metalness: 0.0
      });
      ground = new THREE.Mesh(geo, mat);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);
    }

    function createStars() {
      const starCount = 800;
      const positions = new Float32Array(starCount * 3);

      for (let i = 0; i < starCount; i++) {
        const r = 200;
        const theta = Math.random() * 2 * Math.PI;
        const y = 80 + Math.random() * 40;
        const x = Math.cos(theta) * r;
        const z = Math.sin(theta) * r;
        positions[i * 3] = x;
        positions[i * 3 + 1] = y;
        positions[i * 3 + 2] = z;
      }

      const geo = new THREE.BufferGeometry();
      geo.setAttribute("position", new THREE.BufferAttribute(positions, 3));

      const mat = new THREE.PointsMaterial({
        color: 0x77aaff,
        size: 0.6,
        sizeAttenuation: true
      });

      stars = new THREE.Points(geo, mat);
      scene.add(stars);
    }

    function createTrees() {
      const trunkMat = new THREE.MeshStandardMaterial({
        color: 0x3b2a1a,
        roughness: 0.9
      });
      const leavesMat = new THREE.MeshStandardMaterial({
        color: 0x0b2814,
        roughness: 0.9
      });

      const trunkGeo = new THREE.CylinderGeometry(0.4, 0.6, 5, 8);
      const leavesGeo = new THREE.ConeGeometry(3, 8, 10);

      for (let i = 0; i < 80; i++) {
        const angle = Math.random() * Math.PI * 2;
        const radius = CLEARING_RADIUS + 5 + Math.random() * (PARK_RADIUS - CLEARING_RADIUS - 10);
        const x = Math.cos(angle) * radius;
        const z = Math.sin(angle) * radius;

        const tree = new THREE.Group();

        const trunk = new THREE.Mesh(trunkGeo, trunkMat);
        trunk.position.set(0, 2.5, 0);
        trunk.castShadow = true;
        trunk.receiveShadow = true;

        const leaves = new THREE.Mesh(leavesGeo, leavesMat);
        leaves.position.set(0, 7, 0);
        leaves.castShadow = true;
        leaves.receiveShadow = true;

        tree.add(trunk, leaves);
        tree.position.set(x, 0, z);
        scene.add(tree);

        trees.push({
          object: tree,
          x,
          z,
          radius: 2.2 // collision radius
        });
      }
    }

    // ============ PLAYER ============

    function createPlayer() {
      playerGroup = new THREE.Group();
      playerGroup.position.set(0, 0, 0);
      scene.add(playerGroup);

      const bodyMat = new THREE.MeshStandardMaterial({
        color: 0x88aaff,
        roughness: 0.7
      });
      const legMat = new THREE.MeshStandardMaterial({
        color: 0x444457,
        roughness: 0.85
      });
      const headMat = new THREE.MeshStandardMaterial({
        color: 0xffddb8,
        roughness: 0.7
      });

      // Legs
      const legGeo = new THREE.BoxGeometry(0.25, 0.7, 0.25);
      const leftLeg = new THREE.Mesh(legGeo, legMat);
      const rightLeg = new THREE.Mesh(legGeo, legMat);
      leftLeg.position.set(-0.18, 0.35, 0);
      rightLeg.position.set(0.18, 0.35, 0);

      // Body
      const bodyGeo = new THREE.BoxGeometry(0.6, 0.9, 0.4);
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.position.set(0, 0.95, 0);

      // Head
      const headGeo = new THREE.BoxGeometry(0.45, 0.45, 0.4);
      const head = new THREE.Mesh(headGeo, headMat);
      head.position.set(0, 1.55, 0.05);

      const hairGeo = new THREE.BoxGeometry(0.46, 0.2, 0.4);
      const hairMat = new THREE.MeshStandardMaterial({
        color: 0x222222,
        roughness: 0.8
      });
      const hair = new THREE.Mesh(hairGeo, hairMat);
      hair.position.set(0, 1.68, 0.05);

      playerGroup.add(leftLeg, rightLeg, body, head, hair);

      player = {
        group: playerGroup,
        leftLeg,
        rightLeg,
        yaw: 0,
        moveTime: 0
      };
    }

    function updatePlayer(delta) {
      const running = keys.ShiftLeft || keys.ShiftRight;
      const baseSpeed = 3;
      const runMultiplier = 1.8;

      // stamina
      if (running && stamina > 0.1 && anyMoveKeyDown()) {
        stamina -= 0.5 * delta;
        staminaCooldown = 1.0;
      } else {
        staminaCooldown -= delta;
        if (staminaCooldown <= 0) {
          stamina += 0.3 * delta;
        }
      }
      stamina = Math.max(0, Math.min(1, stamina));
      staminaBar.style.transform = "scaleX(" + stamina.toFixed(3) + ")";

      const effectiveRun = running && stamina > 0.1;
      const speed = baseSpeed * (effectiveRun ? runMultiplier : 1);

      let moveForward = 0;
      let moveSide = 0;
      if (keys.KeyW || keys.ArrowUp) moveForward += 1;
      if (keys.KeyS || keys.ArrowDown) moveForward -= 1;
      if (keys.KeyA || keys.ArrowLeft) moveSide -= 1;
      if (keys.KeyD || keys.ArrowRight) moveSide += 1;

      let moving = false;
      if (moveForward !== 0 || moveSide !== 0) {
        moving = true;
        const len = Math.sqrt(moveForward * moveForward + moveSide * moveSide);
        moveForward /= len;
        moveSide /= len;

        // yaw based on movement direction (no mouse, just cardinal)
        const targetYaw = Math.atan2(moveSide, moveForward);
        player.yaw = targetYaw;

        const forwardX = Math.sin(player.yaw);
        const forwardZ = Math.cos(player.yaw);

        const rightX = Math.sin(player.yaw + Math.PI / 2);
        const rightZ = Math.cos(player.yaw + Math.PI / 2);

        const worldDX = (forwardX * moveForward + rightX * moveSide) * speed * delta;
        const worldDZ = (forwardZ * moveForward + rightZ * moveSide) * speed * delta;

        attemptMove(player.group, worldDX, worldDZ, PLAYER_RADIUS);
      }

      player.group.rotation.y = player.yaw;

      if (moving) {
        player.moveTime += delta * (effectiveRun ? 10 : 6);
        const swing = Math.sin(player.moveTime) * 0.6;
        player.leftLeg.rotation.x = swing;
        player.rightLeg.rotation.x = -swing;
      } else {
        player.leftLeg.rotation.x *= 0.8;
        player.rightLeg.rotation.x *= 0.8;
      }
    }

    function anyMoveKeyDown() {
      return keys.KeyW || keys.KeyA || keys.KeyS || keys.KeyD ||
             keys.ArrowUp || keys.ArrowDown || keys.ArrowLeft || keys.ArrowRight;
    }

    function updateCamera(delta) {
      const height = 1.7;
      const backOffset = cameraDistance;

      const lookPos = new THREE.Vector3(
        player.group.position.x,
        player.group.position.y + 1.2,
        player.group.position.z
      );

      const behindX = Math.sin(player.yaw) * backOffset;
      const behindZ = Math.cos(player.yaw) * backOffset;

      const desiredPos = new THREE.Vector3(
        player.group.position.x - behindX,
        player.group.position.y + height,
        player.group.position.z - behindZ
      );

      camera.position.lerp(desiredPos, 0.15);
      camera.lookAt(lookPos);

      // flashlight follows camera
      const t = performance.now() * 0.002;
      const jitter = flashlight.visible ? 0.04 : 0;
      flashlight.position.copy(camera.position);
      flashlight.position.x += Math.sin(t * 1.7) * jitter;
      flashlight.position.y += Math.sin(t * 2.3) * jitter;

      const target = lookPos.clone();
      flashlight.target.position.lerp(target, 0.3);
      flashlight.target.updateMatrixWorld();
    }

    function updateCameraInstant() {
      camera.position.set(
        player.group.position.x,
        player.group.position.y + 1.7,
        player.group.position.z + cameraDistance
      );
      camera.lookAt(
        player.group.position.x,
        player.group.position.y + 1.2,
        player.group.position.z
      );
    }

    // ============ SKINWALKERS ============

    function createSkinwalker(position) {
      const group = new THREE.Group();
      group.position.copy(position);

      const bodyMat = new THREE.MeshStandardMaterial({
        color: 0x050505,
        roughness: 0.6,
        emissive: 0x220000,
        emissiveIntensity: 0.9
      });
      const limbMat = new THREE.MeshStandardMaterial({
        color: 0x080808,
        roughness: 0.8,
        emissive: 0x220000,
        emissiveIntensity: 0.6
      });
      const headMat = new THREE.MeshStandardMaterial({
        color: 0x111111,
        roughness: 0.6,
        emissive: 0x440000,
        emissiveIntensity: 1.2
      });

      // Tall body
      const bodyGeo = new THREE.BoxGeometry(0.8, 3.2, 0.5);
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.position.set(0, 1.6, 0);

      // Arms
      const armGeo = new THREE.BoxGeometry(0.16, 2.1, 0.16);
      const leftArm = new THREE.Mesh(armGeo, limbMat);
      const rightArm = new THREE.Mesh(armGeo, limbMat);
      leftArm.position.set(-0.7, 1.2, 0);
      rightArm.position.set(0.7, 1.2, 0);

      // Legs (thin)
      const legGeo = new THREE.BoxGeometry(0.18, 2.1, 0.18);
      const leftLeg = new THREE.Mesh(legGeo, limbMat);
      const rightLeg = new THREE.Mesh(legGeo, limbMat);
      leftLeg.position.set(-0.25, 0.6, 0);
      rightLeg.position.set(0.25, 0.6, 0);

      // Head
      const headGeo = new THREE.BoxGeometry(0.7, 0.9, 0.4);
      const head = new THREE.Mesh(headGeo, headMat);
      head.position.set(0, 2.7, 0.1);

      // Eyes
      const eyeGeo = new THREE.BoxGeometry(0.15, 0.15, 0.05);
      const eyeMat = new THREE.MeshStandardMaterial({
        color: 0x88cfff,
        emissive: 0x88cfff,
        emissiveIntensity: 1.7
      });
      const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
      const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
      leftEye.position.set(-0.18, 2.8, 0.28);
      rightEye.position.set(0.18, 2.8, 0.28);

      const glow = new THREE.PointLight(0x88cfff, 1.0, 10);
      glow.position.set(0, 2.7, 0.3);

      group.add(body, leftArm, rightArm, leftLeg, rightLeg, head, leftEye, rightEye, glow);

      scene.add(group);

      return {
        group,
        state: "patrol", // patrol, warning, chase
        target: randomPatrolPoint(),
        speed: 1.3 + Math.random() * 0.4,
        swayTime: Math.random() * 10,
        warningPlayed: false
      };
    }

    function randomPatrolPoint() {
      // somewhere within trees but not too near centre
      while (true) {
        const angle = Math.random() * Math.PI * 2;
        const radius = CLEARING_RADIUS + 5 + Math.random() * (PARK_RADIUS - CLEARING_RADIUS - 10);
        const x = Math.cos(angle) * radius;
        const z = Math.sin(angle) * radius;
        return new THREE.Vector3(x, 0, z);
      }
    }

    function createSkinwalkersForLevel(level) {
      // Remove old ones
      skinwalkers.forEach(s => scene.remove(s.group));
      skinwalkers = [];

      const count = baseSkinwalkers + level - 1;
      for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const radius = CLEARING_RADIUS + 15 + Math.random() * 20;
        const pos = new THREE.Vector3(
          Math.cos(angle) * radius,
          0,
          Math.sin(angle) * radius
        );
        skinwalkers.push(createSkinwalker(pos));
      }
    }

    function updateSkinwalkers(delta) {
      const playerPos = player.group.position;

      let closestDist = Infinity;

      for (const s of skinwalkers) {
        const pos = s.group.position;
        const toPlayer = new THREE.Vector3().subVectors(playerPos, pos);
        const distance = toPlayer.length();
        if (distance < closestDist) closestDist = distance;

        // behaviour
        const attackRadius = 1.3;
        const warningRadius = 13;
        const chaseRadius = 20;

        if (distance < attackRadius && gameState === "playing") {
          triggerDeath("A tall shape steps out of the trees",
            "You heard the whistling too late. Something cold and thin closed the distance in a heartbeat.");
          return;
        }

        if (distance < warningRadius && s.state === "patrol") {
          s.state = "warning";
          if (!s.warningPlayed) {
            s.warningPlayed = true;
            tryPlay(whistleSound, 0.9);
            tryPlay(stepsSound, 0.45);
          }
        }

        if (distance < chaseRadius && s.state !== "chase") {
          s.state = "chase";
        }

        let target;
        let speed = s.speed;

        if (s.state === "patrol") {
          target = s.target;
          if (pos.distanceTo(s.target) < 1) {
            s.target = randomPatrolPoint();
          }
        } else if (s.state === "warning") {
          target = s.target;
          if (pos.distanceTo(s.target) < 1) {
            s.target = randomPatrolPoint();
          }
          speed *= 1.1;
        } else {
          // chase
          target = playerPos;
          speed *= 2.3;
        }

        const dir = new THREE.Vector3().subVectors(target, pos);
        dir.y = 0;
        const len = dir.length();
        if (len > 0.01) {
          dir.normalize();
          const stepX = dir.x * speed * delta;
          const stepZ = dir.z * speed * delta;
          attemptMove(s.group, stepX, stepZ, 0.6);
        }

        // sway / look
        s.swayTime += delta * 2;
        s.group.position.y = Math.sin(s.swayTime) * 0.1;
        s.group.lookAt(playerPos.x, playerPos.y + 1, playerPos.z);
      }

      // adjust danger overlay based on nearest skinwalker
      const maxRange = 35;
      const d = Math.max(0, Math.min(maxRange, maxRange - closestDist));
      const danger = d / maxRange;
      dangerOverlay.style.opacity = (danger * 0.9).toFixed(2);

      if (danger < 0.1) {
        stepsSound.pause();
      }
    }

    // ============ COLLISION ============

    function attemptMove(obj, dx, dz, radius) {
      const newPos = obj.position.clone();
      newPos.x += dx;
      newPos.z += dz;

      // Stay inside park
      const distFromCentre = Math.sqrt(newPos.x * newPos.x + newPos.z * newPos.z);
      if (distFromCentre > PARK_RADIUS - 1) return;

      // Collide with trees
      for (const t of trees) {
        const dxT = newPos.x - t.x;
        const dzT = newPos.z - t.z;
        const distSq = dxT * dxT + dzT * dzT;
        const minDist = radius + t.radius;
        if (distSq < minDist * minDist) {
          return; // blocked
        }
      }

      obj.position.copy(newPos);
    }

    // ============ INPUT HANDLERS ============

    function onKeyDown(e) {
      if (keys.hasOwnProperty(e.code)) {
        keys[e.code] = true;

        if (e.code === "KeyF") {
          flashlight.visible = !flashlight.visible;
        }
      }

      if (gameState === "waiting") {
        gameState = "playing";
        startHint.style.display = "none";
      }

      if (gameState === "dead" && e.code === "Space") {
        restartGame();
      }
    }

    function onKeyUp(e) {
      if (keys.hasOwnProperty(e.code)) {
        keys[e.code] = false;
      }
    }

    function onResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onWheel(e) {
      const delta = e.deltaY > 0 ? 1 : -1;
      cameraDistance += delta * 0.6;
      cameraDistance = Math.max(cameraMin, Math.min(cameraMax, cameraDistance));
    }

    // ============ GAME STATE / LEVELS ============

    function triggerDeath(title, text) {
      if (gameState !== "playing") return;
      gameState = "dead";
      overlay.style.display = "flex";
      overlayTitle.textContent = title;
      overlayTitle.style.color = "#ff4444";
      overlayText.textContent = text;
      dangerOverlay.style.opacity = "1";
      stepsSound.pause();
    }

    function nextLevel() {
      level += 1;
      levelNumEl.textContent = level.toString();
      levelTime = 0;
      createSkinwalkersForLevel(level);
      tryPlay(whistleSound, 0.5);
    }

    function restartGame() {
      overlay.style.display = "none";
      dangerOverlay.style.opacity = "0";
      level = 1;
      levelTime = 0;
      levelNumEl.textContent = "1";
      stamina = 1;
      staminaBar.style.transform = "scaleX(1)";
      player.group.position.set(0, 0, 0);
      createSkinwalkersForLevel(level);
      updateCameraInstant();
      gameState = "playing";
      tryPlay(whistleSound, 0.3);
    }

    // ============ LOOP ============

    function animate() {
      requestAnimationFrame(animate);
      const now = performance.now();
      const delta = (now - lastTime) / 1000;
      lastTime = now;

      if (gameState === "playing") {
        levelTime += delta;
        if (levelTime >= levelLength) {
          nextLevel();
        }

        updatePlayer(delta);
        updateSkinwalkers(delta);
      }

      updateCamera(delta);
      renderer.render(scene, camera);
    }

    // Start
    init();
  </script>
</body>
</html>
