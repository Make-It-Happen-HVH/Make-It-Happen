<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>House Horror</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #fff;
    }

    #ui-top {
      position: fixed;
      top: 10px;
      left: 10px;
      z-index: 10;
      font-size: 13px;
      background: rgba(0, 0, 0, 0.7);
      padding: 6px 10px;
      border-radius: 6px;
    }

    #ui-top strong {
      display: block;
      font-size: 14px;
      margin-bottom: 3px;
    }

    #help {
      position: fixed;
      bottom: 10px;
      left: 10px;
      z-index: 10;
      font-size: 12px;
      background: rgba(0, 0, 0, 0.7);
      padding: 6px 10px;
      border-radius: 6px;
    }

    #overlay {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      background: rgba(0, 0, 0, 0.9);
      z-index: 20;
      text-align: center;
    }

    #overlay h1 {
      font-size: 38px;
      letter-spacing: 2px;
      margin-bottom: 8px;
      text-transform: uppercase;
    }

    #overlay p {
      font-size: 14px;
      margin-bottom: 16px;
      color: #ddd;
      max-width: 280px;
    }

    #overlay button {
      padding: 8px 16px;
      border-radius: 6px;
      border: 1px solid #fff;
      background: transparent;
      color: #fff;
      cursor: pointer;
      font-size: 13px;
    }

    #overlay button:hover {
      background: #fff;
      color: #000;
    }
  </style>
</head>
<body>
  <div id="ui-top">
    <strong>House Horror</strong>
    <div>Objectives: <span id="objCount">0</span> / <span id="objTotal">3</span></div>
    <div>Stay away from the tall thing in the halls</div>
  </div>

  <div id="help">Move with W A S D or arrow keys</div>

  <div id="overlay">
    <h1 id="overlayTitle"></h1>
    <p id="overlayText"></p>
    <button id="overlayBtn">Restart</button>
  </div>

  <!-- Three.js CDN -->
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>

  <script>
    let scene, camera, renderer;
    let player, monster, flashlight;
    let walls = [];
    let toys = [];
    let collected = 0;
    const totalToys = 3;

    const HOUSE_SIZE = 32;
    const keysState = {
      KeyW: false,
      KeyA: false,
      KeyS: false,
      KeyD: false,
      ArrowUp: false,
      ArrowDown: false,
      ArrowLeft: false,
      ArrowRight: false
    };

    let lastTime = 0;
    let gameState = "playing"; // playing, win, lose
    let monsterTarget = null;
    const overlay = document.getElementById("overlay");
    const overlayTitle = document.getElementById("overlayTitle");
    const overlayText = document.getElementById("overlayText");
    const overlayBtn = document.getElementById("overlayBtn");
    const objCountEl = document.getElementById("objCount");
    const objTotalEl = document.getElementById("objTotal");

    objTotalEl.textContent = totalToys.toString();

    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);
      scene.fog = new THREE.Fog(0x000000, 3, 40);

      camera = new THREE.PerspectiveCamera(
        70,
        window.innerWidth / window.innerHeight,
        0.1,
        200
      );

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Lights
      const ambient = new THREE.AmbientLight(0xffffff, 0.05);
      scene.add(ambient);

      const houseLight = new THREE.DirectionalLight(0x666699, 0.3);
      houseLight.position.set(10, 15, -8);
      scene.add(houseLight);

      flashlight = new THREE.SpotLight(0xffffff, 2, 20, Math.PI / 7, 0.5, 1.5);
      flashlight.position.set(0, 5, 5);
      flashlight.target.position.set(0, 0, 0);
      scene.add(flashlight);
      scene.add(flashlight.target);

      // Floor
      const floorGeo = new THREE.PlaneGeometry(HOUSE_SIZE, HOUSE_SIZE);
      const floorMat = new THREE.MeshStandardMaterial({
        color: 0x111111,
        roughness: 0.9
      });
      const floor = new THREE.Mesh(floorGeo, floorMat);
      floor.rotation.x = -Math.PI / 2;
      floor.receiveShadow = true;
      scene.add(floor);

      createHouseLayout();
      createPlayer();
      createMonster();
      createToys();

      camera.position.set(player.position.x, 5, player.position.z + 6);
      camera.lookAt(player.position);

      window.addEventListener("keydown", onKeyDown);
      window.addEventListener("keyup", onKeyUp);
      window.addEventListener("resize", onResize);
      overlayBtn.addEventListener("click", restartGame);

      lastTime = performance.now();
      animate();
    }

    function createHouseLayout() {
      const wallMat = new THREE.MeshStandardMaterial({
        color: 0x202020,
        roughness: 0.8
      });

      const thickness = 0.8;
      const height = 3;

      function makeWall(width, depth, x, z) {
        const geo = new THREE.BoxGeometry(width, height, depth);
        const mesh = new THREE.Mesh(geo, wallMat);
        mesh.position.set(x, height / 2, z);
        scene.add(mesh);
        walls.push(mesh);
      }

      // Outer walls (simple rectangle)
      makeWall(HOUSE_SIZE, thickness, 0, -HOUSE_SIZE / 2);
      makeWall(HOUSE_SIZE, thickness, 0, HOUSE_SIZE / 2);
      makeWall(thickness, HOUSE_SIZE, -HOUSE_SIZE / 2, 0);
      makeWall(thickness, HOUSE_SIZE, HOUSE_SIZE / 2, 0);

      // Inner layout: hallways and rooms
      // Long central hallway
      makeWall(HOUSE_SIZE - 8, thickness, 0, 0);

      // Cross walls creating rooms
      makeWall(thickness, 12, -6, -8);
      makeWall(thickness, 10, 6, 8);

      // Short walls to create door gaps
      makeWall(8, thickness, -12, -4);
      makeWall(8, thickness, 12, 4);

      // A few pillars
      makeWall(2, 2, -10, 10);
      makeWall(2, 2, 10, -10);
    }

    function createPlayer() {
      const bodyGeo = new THREE.BoxGeometry(0.6, 1.0, 0.4);
      const bodyMat = new THREE.MeshStandardMaterial({ color: 0xddddff });
      player = new THREE.Mesh(bodyGeo, bodyMat);
      player.position.set(-HOUSE_SIZE / 2 + 3, 0.5, -HOUSE_SIZE / 2 + 3);
      scene.add(player);
    }

    function createMonster() {
      const monsterGeo = new THREE.BoxGeometry(0.8, 3.5, 0.5);
      const monsterMat = new THREE.MeshStandardMaterial({
        color: 0x111111,
        emissive: 0x550000,
        emissiveIntensity: 0.9
      });
      monster = new THREE.Mesh(monsterGeo, monsterMat);
      monster.position.set(4, 1.75, 0);
      scene.add(monster);

      const eyesGeo = new THREE.BoxGeometry(0.1, 0.1, 0.05);
      const eyesMat = new THREE.MeshStandardMaterial({
        color: 0xff0000,
        emissive: 0xff0000,
        emissiveIntensity: 1.5
      });
      const leftEye = new THREE.Mesh(eyesGeo, eyesMat);
      const rightEye = new THREE.Mesh(eyesGeo, eyesMat);
      leftEye.position.set(-0.2, 0.8, 0.28);
      rightEye.position.set(0.2, 0.8, 0.28);
      monster.add(leftEye);
      monster.add(rightEye);

      const monsterLight = new THREE.PointLight(0xff0000, 1.1, 8);
      monster.add(monsterLight);
    }

    function createToys() {
      const toyPositions = [
        new THREE.Vector3(-10, 0.2, 8),
        new THREE.Vector3(10, 0.2, -8),
        new THREE.Vector3(0, 0.2, 10)
      ];

      const toyGeo = new THREE.SphereGeometry(0.25, 18, 18);

      toyPositions.forEach((pos) => {
        const toyMat = new THREE.MeshStandardMaterial({
          color: 0x00ffd5,
          emissive: 0x00ffd5,
          emissiveIntensity: 1.2
        });
        const toy = new THREE.Mesh(toyGeo, toyMat);
        toy.position.copy(pos);
        scene.add(toy);
        toys.push(toy);
      });
    }

    // Input
    function onKeyDown(e) {
      if (keysState.hasOwnProperty(e.code)) {
        keysState[e.code] = true;
      }
    }

    function onKeyUp(e) {
      if (keysState.hasOwnProperty(e.code)) {
        keysState[e.code] = false;
      }
    }

    function onResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // Collision helper
    function attemptMove(obj, dx, dz, radius = 0.4) {
      const newPos = obj.position.clone();
      newPos.x += dx;
      newPos.z += dz;

      for (const wall of walls) {
        const wx = wall.position.x;
        const wy = wall.position.y;
        const wz = wall.position.z;

        const params = wall.geometry.parameters;
        const sx = (params.width || params.depth) / 2;
        const sy = params.height / 2;
        const sz = (params.depth || params.width) / 2;

        if (
          newPos.x + radius > wx - sx &&
          newPos.x - radius < wx + sx &&
          newPos.y + radius > wy - sy &&
          newPos.y - radius < wy + sy &&
          newPos.z + radius > wz - sz &&
          newPos.z - radius < wz + sz
        ) {
          return;
        }
      }

      obj.position.copy(newPos);
    }

    function updatePlayer(delta) {
      const speed = 3.5 * delta;
      let dx = 0;
      let dz = 0;

      if (keysState.KeyW || keysState.ArrowUp) dz -= speed;
      if (keysState.KeyS || keysState.ArrowDown) dz += speed;
      if (keysState.KeyA || keysState.ArrowLeft) dx -= speed;
      if (keysState.KeyD || keysState.ArrowRight) dx += speed;

      if (dx !== 0 && dz !== 0) {
        const inv = 1 / Math.sqrt(2);
        dx *= inv;
        dz *= inv;
      }

      attemptMove(player, dx, dz, 0.35);

      player.rotation.y = Math.atan2(dx, dz);

      // Collect toys
      for (const toy of toys) {
        if (!toy.visible) continue;
        const dist = toy.position.distanceTo(player.position);
        if (dist < 0.7) {
          toy.visible = false;
          collected += 1;
          objCountEl.textContent = collected.toString();
          if (collected >= totalToys && gameState === "playing") {
            triggerWin();
          }
        } else {
          toy.rotation.y += delta * 3;
        }
      }
    }

    function chooseNewMonsterTarget() {
      const spots = [
        new THREE.Vector3(-12, monster.position.y, -4),
        new THREE.Vector3(-8, monster.position.y, 8),
        new THREE.Vector3(8, monster.position.y, 0),
        new THREE.Vector3(12, monster.position.y, -8),
        new THREE.Vector3(0, monster.position.y, 0)
      ];
      monsterTarget = spots[Math.floor(Math.random() * spots.length)].clone();
    }

    function updateMonster(delta) {
      const baseSpeed = 1.2;
      const chaseSpeed = 2.4;

      const toPlayer = new THREE.Vector3().subVectors(
        player.position,
        monster.position
      );
      const distToPlayer = toPlayer.length();

      let speed = baseSpeed;
      let targetPos;

      if (distToPlayer < 7) {
        // Chase mode
        targetPos = player.position;
        speed = chaseSpeed;
      } else {
        // Patrol mode
        if (!monsterTarget || monster.position.distanceTo(monsterTarget) < 0.5) {
          chooseNewMonsterTarget();
        }
        targetPos = monsterTarget;
      }

      const dir = new THREE.Vector3().subVectors(targetPos, monster.position);
      dir.y = 0;
      const dist = dir.length();
      if (dist > 0.01) {
        dir.normalize();
        const stepX = dir.x * speed * delta;
        const stepZ = dir.z * speed * delta;
        attemptMove(monster, stepX, stepZ, 0.3);
      }

      monster.position.y = 1.75 + Math.sin(performance.now() * 0.004) * 0.1;
      monster.lookAt(player.position.x, monster.position.y, player.position.z);

      const catchDistance = 1.1;
      if (distToPlayer < catchDistance && gameState === "playing") {
        triggerLose();
      }
    }

    function updateCameraAndLight() {
      const camOffset = new THREE.Vector3(0, 5, 6);
      const camPos = player.position.clone().add(camOffset);
      camera.position.lerp(camPos, 0.18);
      camera.lookAt(player.position.x, 0.7, player.position.z);

      flashlight.position.copy(camera.position);
      const targetPos = player.position.clone();
      flashlight.target.position.lerp(targetPos, 0.3);
      flashlight.target.updateMatrixWorld();
    }

    function triggerLose() {
      gameState = "lose";
      overlayTitle.textContent = "You Were Caught";
      overlayTitle.style.color = "#ff4444";
      overlayText.textContent = "The tall thing found you wandering the halls. Try again and move more carefully.";
      overlay.style.display = "flex";
    }

    function triggerWin() {
      gameState = "win";
      overlayTitle.textContent = "You Escaped";
      overlayTitle.style.color = "#66ff99";
      overlayText.textContent = "You collected all your toys and slipped out before the monster caught you.";
      overlay.style.display = "flex";
    }

    function restartGame() {
      gameState = "playing";
      overlay.style.display = "none";
      collected = 0;
      objCountEl.textContent = "0";

      player.position.set(-HOUSE_SIZE / 2 + 3, 0.5, -HOUSE_SIZE / 2 + 3);
      monster.position.set(4, 1.75, 0);
      monsterTarget = null;

      toys.forEach((toy) => {
        toy.visible = true;
      });
    }

    function animate() {
      requestAnimationFrame(animate);

      const now = performance.now();
      const delta = (now - lastTime) / 1000;
      lastTime = now;

      if (gameState === "playing") {
        updatePlayer(delta);
        updateMonster(delta);
        updateCameraAndLight();
      } else {
        updateCameraAndLight();
      }

      renderer.render(scene, camera);
    }

    init();
  </script>
</body>
</html>
